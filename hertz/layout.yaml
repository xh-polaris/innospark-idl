layouts:
  # 生成的 dal 的目录，只有目录下有文件才会生成
  - path: biz/dal/
    delims:
      - ""
      - ""
    body: ""
  # 生成的 handler 的目录，只有目录下有文件才会生成
  - path: biz/handler/
    delims:
      - ""
      - ""
    body: ""
  # 生成的 model 的目录，只有目录下有文件才会生成
  - path: biz/model/
    delims:
      - ""
      - ""
    body: ""
  # 生成的 service 的目录，只有目录下有文件才会生成
  - path: biz/service/
    delims:
      - ""
      - ""
    body: ""
  # 项目 main.go 文件
  - path: main.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.
      
      package main
      
      import (
          "context"
          "net/http"
        
          "github.com/cloudwego/hertz/pkg/app"
          "github.com/cloudwego/hertz/pkg/app/middlewares/server/recovery"
          "github.com/cloudwego/hertz/pkg/app/server"
          "github.com/cloudwego/hertz/pkg/common/hlog"
      	  prometheus "github.com/hertz-contrib/monitor-prometheus"
          "github.com/hertz-contrib/obs-opentelemetry/tracing"
          "github.com/xh-polaris/gopkg/hertz/middleware"
          "{{.GoModule}}/biz/infra/util/logx"
          xhlog "github.com/xh-polaris/gopkg/util/log"
          "{{.GoModule}}/provider"
          "{{.GoModule}}/biz/adaptor"
          "go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp"
          "go.opentelemetry.io/contrib/propagators/b3"
          "go.opentelemetry.io/otel"
          "go.opentelemetry.io/otel/propagation"
      )
      
      func Init() {
          // 初始化依赖注入
          provider.Init()
          // 初始化自定义日志
          hlog.SetLogger(xhlog.NewHlogLogger())
          // 设置openTelemetry的传播器，用于分布式追踪中传递上下文信息
          otel.SetTextMapPropagator(propagation.NewCompositeTextMapPropagator(b3.New(), propagation.Baggage{}, propagation.TraceContext{}))
          http.DefaultTransport = otelhttp.NewTransport(http.DefaultTransport)
      }

      func main() {
          Init()
          c := provider.Get().Config
          
          // 创建服务器追踪器
          tracer, cfg := tracing.NewServerTracer()
          // 创造hertz服务器实例
          h := server.New(
              server.WithHostPorts(c.ListenOn),
              server.WithTracer(prometheus.NewServerTracer(":9091", "/server/metrics")),
              tracer,
          )
      
          h.NoHijackConnPool = true
          
          // 增加全局中间件链
          h.Use(tracing.ServerMiddleware(cfg), middleware.EnvironmentMiddleware, recovery.Recovery(), func(ctx context.Context, c *app.RequestContext) {
              ctx = adaptor.InjectContext(ctx, c)
              c.Next(ctx)
          })
      
          // 注册路由
          register(h)
          logx.Info("server start")
          
          h.Spin()
      }

  # go.mod 文件，需要模板渲染数据 {{.GoModule}} {{.UseApacheThrift}} 才能生成
  - path: go.mod
    delims:
      - '{{'
      - '}}'
    body: |-
      module {{.GoModule}}
      {{- if .UseApacheThrift}}
      replace github.com/apache/thrift => github.com/apache/thrift v0.13.0
      {{- end}}
  # .gitignore 文件
  - path: .gitignore
    delims:
      - ""
      - ""
    body: "*.o\n*.a\n*.so\n_obj\n_test\n*.[568vq]\n[568vq].out\n*.cgo1.go\n*.cgo2.c\n_cgo_defun.c\n_cgo_gotypes.go\n_cgo_export.*\n_testmain.go\n*.exe\n*.exe~\n*.test\n*.prof\n*.rar\n*.zip\n*.gz\n*.psd\n*.bmd\n*.cfg\n*.pptx\n*.log\n*nohup.out\n*settings.pyc\n*.sublime-project\n*.sublime-workspace\n!.gitkeep\n.DS_Store\n/.idea\n/.vscode\n/etc\n/output\n*.local.yml\ndumped_hertz_remote_config.json\n\t\t
    \ "
  # handler 中的 ping.go 文件，需要模板渲染数据 {{.HandlerPkg}} 才能生成
  - path: biz/handler/ping.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.

      package {{.HandlerPkg}}

      import (
      	"context"

      	"github.com/cloudwego/hertz/pkg/app"
      	"github.com/cloudwego/hertz/pkg/common/utils"
        "github.com/cloudwego/hertz/pkg/protocol/consts"
      )

      // Ping .
      func Ping(ctx context.Context, c *app.RequestContext) {
      	c.JSON(consts.StatusOK, utils.H{
      		"message": "pong",
      	})
      }
  # 定义路由注册的文件，需要模板渲染数据 {{.RouterPkgPath}} 才能生成
  - path: router_gen.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package main

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      	router "{{.RouterPkgPath}}"
      )

      // register registers all routers.
      func register(r *server.Hertz) {

      	router.GeneratedRegister(r)

      	customizedRegister(r)
      }
  # 自定义路由注册的文件，需要模板渲染数据 {{.HandlerPkgPath}} 才能生成
  - path: router.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator.

      package main

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      	handler "{{.HandlerPkgPath}}"
      )

      // customizeRegister registers customize routers.
      func customizedRegister(r *server.Hertz){
      	r.GET("/ping", handler.Ping)

      	// your code ...
      }
  # 默认路由注册文件，不要修改，需要模板渲染数据 {{.RouterPkg}} 才能生成
  - path: biz/router/register.go
    delims:
      - ""
      - ""
    body: |-
      // Code generated by hertz generator. DO NOT EDIT.

      package {{.RouterPkg}}

      import (
      	"github.com/cloudwego/hertz/pkg/app/server"
      )

      // GeneratedRegister registers routers generated by IDL.
      func GeneratedRegister(r *server.Hertz){
      	//INSERT_POINT: DO NOT DELETE THIS LINE!
      }
  # 编译脚本，需要模板渲染数据 {{.ServiceName}} 才能生成
  - path: build.sh
    delims:
      - ""
      - ""
    body: |-
      #!/bin/bash
      RUN_NAME={{.ServiceName}}
      mkdir -p output/bin
      cp script/* output 2>/dev/null
      chmod +x output/bootstrap.sh
      go build -o output/bin/${RUN_NAME}
  # 运行脚本，需要模板渲染数据 {{.ServiceName}} 才能生成
  - path: script/bootstrap.sh
    delims:
      - ""
      - ""
    body: |-
      #!/bin/bash
      CURDIR=$(cd $(dirname $0); pwd)
      BinaryName={{.ServiceName}}
      echo "$CURDIR/bin/${BinaryName}"
      exec $CURDIR/bin/${BinaryName}
  - path: biz/adaptor/common.go
    delims:
      - ""
      - ""
    body: |-
      package adaptor
  
      import (
          "context"
          "encoding/json"
          "errors"
      	  "reflect"
          "strings"
          
          "github.com/cloudwego/hertz/pkg/app"
      	  "github.com/cloudwego/hertz/pkg/protocol"
      	  hertz "github.com/cloudwego/hertz/pkg/protocol/consts"
          "github.com/golang-jwt/jwt/v4"
          "github.com/xh-polaris/gopkg/util"
          "{{.GoModule}}/biz/infra/config"
          "{{.GoModule}}/biz/infra/cst"
          "{{.GoModule}}/biz/infra/util/logx"
          "go.opentelemetry.io/contrib/propagators/b3"
          "go.opentelemetry.io/otel/propagation"
      )
      
      const hertzContext = "hertz_context"
      
      func InjectContext(ctx context.Context, c *app.RequestContext) context.Context {
          return context.WithValue(ctx, hertzContext, c)
      }
      
      func ExtractContext(ctx context.Context) (*app.RequestContext, error) {
          c, ok := ctx.Value(hertzContext).(*app.RequestContext)
          if !ok {
              return nil, errors.New("hertz context not found")
          }
          return c, nil
      }
      
      func ExtractUserId(ctx context.Context) (userId string, err error) {
          userId = ""
          defer func() {
              if err != nil {
                  logx.CtxInfo(ctx, "extract user meta fail, err=%v", err)
              }
          }()
          c, err := ExtractContext(ctx)
          if err != nil {
              return
          }
          tokenString := c.GetHeader("Authorization")
          token, err := jwt.Parse(string(tokenString), func(_ *jwt.Token) (interface{}, error) {
              return jwt.ParseECPublicKeyFromPEM([]byte(config.GetConfig().Auth.PublicKey))
          })
          if err != nil {
              return
          }
          if !token.Valid {
              err = errors.New("token is not valid")
              return
          }
          data, err := json.Marshal(token.Claims)
          if err != nil {
              return
          }
          var claims map[string]interface{}
          err = json.Unmarshal(data, &claims)
          if err != nil {
              return
          }
          return claims["userId"].(string), err
      }
      
      // PostProcess 处理http响应, resp要求指针或接口类型
      // 在日志中记录本次调用详情, 同时向响应头中注入符合b3规范的链路信息, 主要是trace_id
      // 最佳实践:
      // - 在controller中调用业务处理, 处理结束后调用PostProcess
      func PostProcess(ctx context.Context, c *app.RequestContext, req, resp any, err error) {
      	b3.New().Inject(ctx, &headerProvider{headers: &c.Response.Header})
      	logx.CtxInfo(ctx, "[%s] req=%s, resp=%s, err=%v", c.Path(), util.JSONF(req), util.JSONF(resp), err)

      	// 无错, 正常响应
      	if err == nil {
      		response := makeResponse(resp)
      		c.JSON(hertz.StatusOK, response)
      		return
      	}

      	if ex, ok := err.(cst.IErrorx); ok { // errorx错误
      		StatusCode := hertz.StatusOK
      		c.JSON(StatusCode, &cst.Errorx{
      			Code: ex.GetCode(),
      			Msg:  ex.GetMsg(),
      		})
      	} else { // 常规错误, 状态码500
      		logx.CtxError(ctx, "internal error, err=%s", err.Error())
      		code := hertz.StatusInternalServerError
      		c.String(code, err.Error())
      	}
      }

      // makeResponse 通过反射构造嵌套格式的响应体
      func makeResponse(resp any) map[string]any {
      	v := reflect.ValueOf(resp)
      	if v.Kind() != reflect.Ptr || v.Elem().Kind() != reflect.Struct {
      		return nil
      	}
      	// 构建返回数据
      	v = v.Elem()
      	response := map[string]any{
      		"code": v.FieldByName("Code").Int(),
      		"msg":  v.FieldByName("Msg").String(),
      	}
      	data := make(map[string]any)
      	for i := 0; i < v.NumField(); i++ {
      		field := v.Type().Field(i)
      		if jsonTag := field.Tag.Get("json"); jsonTag != "" && field.Name != "Code" && field.Name != "Msg" {
      			if fieldValue := v.Field(i).Interface(); !reflect.ValueOf(fieldValue).IsZero() || !strings.Contains(jsonTag, "omitempty") {
      				data[jsonTag] = fieldValue
      			}
      		}
      	}
      	if len(data) > 0 {
      		response["data"] = data
      	}
      	return response
      }
      var _ propagation.TextMapCarrier = &headerProvider{}
      
      type headerProvider struct {
          headers *protocol.ResponseHeader
      }
      
      // Get a value from metadata by key
      func (m *headerProvider) Get(key string) string {
          return m.headers.Get(key)
      }
      
      // Set a value to metadata by k/v
      func (m *headerProvider) Set(key, value string) {
          m.headers.Set(key, value)
      }
      
      // Keys Iteratively get all keys of metadata
      func (m *headerProvider) Keys() []string {
          out := make([]string, 0)
      
          m.headers.VisitAll(func(key, value []byte) {
              out = append(out, string(key))
          })
      
          return out
      }
  - path: biz/infra/config/config.go
    delims:
        - ""
        - ""
    body: |-
      package config

      import (
          "os"
  
          "github.com/zeromicro/go-zero/core/service"
  
          "github.com/zeromicro/go-zero/core/conf"
      )

      var config *Config

      type Auth struct {
          SecretKey    string
          PublicKey    string
          AccessExpire int64
      }

      type Config struct {
          service.ServiceConf
          ListenOn           string
          Auth               Auth
      }

      func NewConfig() (*Config, error) {
          c := new(Config)
          path := os.Getenv("CONFIG_PATH")
          if path == "" {
              path = "etc/config.yaml"
          }
          err := conf.Load(path, c)
          if err != nil {
              return nil, err
          }
          err = c.SetUp()
          if err != nil {
              return nil, err
          }
          config = c
          return c, nil
      }

      func GetConfig() *Config {
      	  return config
      }
  - path: biz/infra/cst/cst.go
    delims:
        - ""
        - ""
    body: |-
      package cst
  - path: biz/infra/cst/errx.go
    delims:
        - ""
        - ""
    body: |-
      package cst

      import (
      	"fmt"
      )

      const unknowCode = 999

      // Errorx 是HTTP服务的业务异常
      // 若返回Errorx给前端, 则HTTP状态码应该是200, 且响应体为Errorx内容
      // 最佳实践:
      // - 业务处理链路的末端使用Errorx, PostProcess处理后给出用户友好的响应
      // - 预定义一些Errorx作为常量
      // - 除却末端的Errorx外, 其余的error照常处理

      type IErrorx interface {
      	GetCode() int
      	GetMsg() string
      }

      type Errorx struct {
      	Code int    `json:"code"`
      	Msg  string `json:"msg"`
      }

      func New(code int, msg string) *Errorx {
      	return &Errorx{
      		Code: code,
      		Msg:  msg,
      	}
      }

      // Error 实现了error接口, 返回错误字符串
      func (e Errorx) Error() string {
      	return fmt.Sprintf("code=%d, msg=%s", e.Code, e.Msg)
      }

      // GetCode 获取Code
      func (e Errorx) GetCode() int {
      	return e.Code
      }

      // GetMsg 获取Msg
      func (e Errorx) GetMsg() string {
      	return e.Msg
      }
  - path: biz/infra/util/logx/logx.go
    delims:
      - ""
      - ""
    body: |-
      package logx

      import (
      	"context"

      	"github.com/zeromicro/go-zero/core/logx"
      )

      func getLoggerCtx(ctx context.Context) logx.Logger {
      	return logx.WithContext(ctx).WithCallerSkip(1)
      }

      func getLogger() logx.Logger {
      	return logx.WithCallerSkip(1)
      }

      func CtxInfo(ctx context.Context, format string, v ...any) {
      	getLoggerCtx(ctx).Infof(format, v...)
      }

      func Info(format string, v ...any) {
      	getLogger().Infof(format, v...)
      }

      func CtxError(ctx context.Context, format string, v ...any) {
      	getLoggerCtx(ctx).Errorf(format, v...)
      }

      func Error(format string, v ...any) {
      	getLogger().Errorf(format, v...)
      }

      func CondError(cond bool, format string, v ...any) {
      	if cond {
      		getLogger().Errorf(format, v...)
      	}
      }

      func CtxDebug(ctx context.Context, format string, v ...any) {
      	getLoggerCtx(ctx).Debugf(format, v...)
      }
  - path: provider/provider.go
    delims:
      - ""
      - ""
    body: |-
      package provider

      import (
      	"github.com/google/wire"
      	"{{.GoModule}}/biz/infra/config"
      )

      var provider *Provider

      func Init() {
      	var err error
      	provider, err = NewProvider()
      	if err != nil {
      		panic(err)
      	}
      }

      // Provider 提供controller依赖的对象
      type Provider struct {
      	Config          *config.Config
      }

      func Get() *Provider {
      	return provider
      }

      var RPCSet = wire.NewSet(
      )

      var ApplicationSet = wire.NewSet(
      )

      var DomainSet = wire.NewSet()

      var InfraSet = wire.NewSet(
      	config.NewConfig,
      	RPCSet,
      )

      var AllProvider = wire.NewSet(
      	ApplicationSet,
      	DomainSet,
      	InfraSet,
      )
  - path: provider/wire.go
    delims:
      - ""
      - ""
    body: |-
      //go:build wireinject
      // +build wireinject
  
      package provider

      import (
          "github.com/google/wire"
      )
  
      func NewProvider() (*Provider, error) {
          wire.Build(
            AllProvider,
            wire.Struct(new(Provider), "*"),
          )
          return nil, nil
      }
  - path: Dockerfile
    delims:
      - ""
      - ""
    body: |-
      FROM golang:1.24-alpine AS builder

      LABEL stage=gobuilder

      ENV CGO_ENABLED 0
      RUN sed -i 's/dl-cdn.alpinelinux.org/mirrors.aliyun.com/g' /etc/apk/repositories

      RUN apk update --no-cache && apk add --no-cache tzdata

      WORKDIR /build

      ADD go.mod .
      ADD go.sum .
      RUN go mod download
      COPY . .
      RUN sh ./build.sh

      FROM alpine

      COPY --from=builder /usr/share/zoneinfo/Asia/Shanghai /usr/share/zoneinfo/Asia/Shanghai

      ENV TZ Asia/Shanghai

      WORKDIR /app
      COPY --from=builder /build/output /app

      CMD ["sh", "./bootstrap.sh"]
